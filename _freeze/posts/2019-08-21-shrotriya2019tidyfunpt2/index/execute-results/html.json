{
  "hash": "a0efa7e10e044d7c826d2ba3319b379e",
  "result": {
    "markdown": "---\ntitle: \"Tidyverse Fun - Part 2\"\ndescription: |\n  Second part in a series of doing useful tasks with\n  the `Tidyverse`. This time auto-generating sequential\n  LaTeX `newcommand` macros\ncategories: [tidyverse, rstats]\nslug: shrotriya2019tidyfunpt2\ndate: \"2019-08-24\"\nimage: images/logo-01.jpg\nbibliography: ../../refs.bib\nformat: \n  html:\n    code-link: true\nexecute:\n  echo: true\neditor_options: \n  markdown: \n    wrap: 80\n---\n\n\n## Task: Generating LaTeX newcommand macros\n\n### The central problem\n\nIn a custom $\\LaTeX$ macro file I needed to generate several sequential\n$\\LaTeX$ `newcommand` entries of the form:\n\n```markup\n\\newcommand{\\bfa}{\\mathbf{a}}\n\\newcommand{\\bfA}{\\mathbf{A}}\n```\n\nWhere using `$\\bfa$` produces $\\mathbf{a}$ and using `$\\bfA$` produces\n$\\mathbf{A}$ i.e the lowecase/uppercase `mathbf` commands respectively.\n\nSpecifically I needed to construct 52 such combined sequential entries for both\nlowercase/uppercase letter versions of these `newcommand` $\\LaTeX$ macros.\nRather than do this manually, I realized that this would be another fun\nscripting exercise with using the `tidyverse` packages `glue`, `purrr`, and\n`stringr` similar to this similar [previous post\nhere](https://www.shamindras.com/posts/2019-07-15-shrotriya2019tidyfunpt1/).\n\n**Goal:** Create 52 such lowercase/uppercase `newcommand` entries and print to\nthe console to directly-copy paste to my $\\LaTeX$ macros file.\n\n### The `tidy` approach\n\nFirst step is to write a function that takes as an input the following:\n\n- a single letter (case-sensitive) e.g. `\"a\"`\n- the macro shortcut command prefix you prefer e.g `\"bf\"`\n(for **b**old **f**ont in case you were wondering!)\n- the specific $\\LaTeX$ command that we are creating a macro shortcut for\ni.e. `\"mathbf\"` in this case\n\nThe function then outputs a single `newcommand` entry for that lecture i.e\n`\\newcommand{\\bfa}{\\mathbf{a}}` in this case. Let's do it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load required libraries\nlibrary(tidyverse)\nlibrary(glue)\n\n# Create LaTeX macro newcommand\nget_lec_newcmd <- function(inp_letr, mac_type, mac_ref){\n    out_str <- glue::glue('\\\\newcommand{\\\\<mac_type><inp_letr>}{\\\\<mac_ref>{<inp_letr>}}',\n                          .open = \"<\", .close = \">\")\n    base::return(out_str)\n}\n```\n:::\n\n\nLet's just test this out quickly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"a\", \"A\") %>%\n    purrr::map_chr(.x = ., .f = ~get_lec_newcmd(inp_letr = .x,\n                                                mac_type = \"bf\",\n                                                mac_ref = \"mathbf\")) %>%\n    cat(., sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\newcommand{\\bfa}{\\mathbf{a}}\n\\newcommand{\\bfA}{\\mathbf{A}}\n```\n:::\n:::\n\n\nGreat - looks like it is working as required!\n\nNote that we can easily generate other $\\LaTeX$ macros like follows\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"a\", \"A\") %>%\n    purrr::map_chr(.x = ., .f = ~get_lec_newcmd(inp_letr = .x,\n                                                mac_type = \"mc\",\n                                                mac_ref = \"mathcal\")) %>%\n    cat(., sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\newcommand{\\mca}{\\mathcal{a}}\n\\newcommand{\\mcA}{\\mathcal{A}}\n```\n:::\n:::\n\n\nWhich generates the corresponding `mathcal` macros for $\\mathcal{a}$ and\n$\\mathcal{A}$ respectively.\n\nSo finally we can generate all 52 letter macros at time by simply replacing\n`c(\"a\", \"A\")` with `c(letters, LETTERS)` which uses the input\nlowercase/uppercase `letters`/`LETTERS` vectors in base `R`:\n\n\n::: {.cell-output-display}\n<details closed>\n<summary> <span title='Click to Expand'> Full newcommand Demo Output </span> </summary>\n\n```r\n\n\\newcommand{\\bfa}{\\mathbf{a}}\n\\newcommand{\\bfb}{\\mathbf{b}}\n\\newcommand{\\bfc}{\\mathbf{c}}\n\\newcommand{\\bfd}{\\mathbf{d}}\n\\newcommand{\\bfe}{\\mathbf{e}}\n\\newcommand{\\bff}{\\mathbf{f}}\n\\newcommand{\\bfg}{\\mathbf{g}}\n\\newcommand{\\bfh}{\\mathbf{h}}\n\\newcommand{\\bfi}{\\mathbf{i}}\n\\newcommand{\\bfj}{\\mathbf{j}}\n\\newcommand{\\bfk}{\\mathbf{k}}\n\\newcommand{\\bfl}{\\mathbf{l}}\n\\newcommand{\\bfm}{\\mathbf{m}}\n\\newcommand{\\bfn}{\\mathbf{n}}\n\\newcommand{\\bfo}{\\mathbf{o}}\n\\newcommand{\\bfp}{\\mathbf{p}}\n\\newcommand{\\bfq}{\\mathbf{q}}\n\\newcommand{\\bfr}{\\mathbf{r}}\n\\newcommand{\\bfs}{\\mathbf{s}}\n\\newcommand{\\bft}{\\mathbf{t}}\n\\newcommand{\\bfu}{\\mathbf{u}}\n\\newcommand{\\bfv}{\\mathbf{v}}\n\\newcommand{\\bfw}{\\mathbf{w}}\n\\newcommand{\\bfx}{\\mathbf{x}}\n\\newcommand{\\bfy}{\\mathbf{y}}\n\\newcommand{\\bfz}{\\mathbf{z}}\n\\newcommand{\\bfA}{\\mathbf{A}}\n\\newcommand{\\bfB}{\\mathbf{B}}\n\\newcommand{\\bfC}{\\mathbf{C}}\n\\newcommand{\\bfD}{\\mathbf{D}}\n\\newcommand{\\bfE}{\\mathbf{E}}\n\\newcommand{\\bfF}{\\mathbf{F}}\n\\newcommand{\\bfG}{\\mathbf{G}}\n\\newcommand{\\bfH}{\\mathbf{H}}\n\\newcommand{\\bfI}{\\mathbf{I}}\n\\newcommand{\\bfJ}{\\mathbf{J}}\n\\newcommand{\\bfK}{\\mathbf{K}}\n\\newcommand{\\bfL}{\\mathbf{L}}\n\\newcommand{\\bfM}{\\mathbf{M}}\n\\newcommand{\\bfN}{\\mathbf{N}}\n\\newcommand{\\bfO}{\\mathbf{O}}\n\\newcommand{\\bfP}{\\mathbf{P}}\n\\newcommand{\\bfQ}{\\mathbf{Q}}\n\\newcommand{\\bfR}{\\mathbf{R}}\n\\newcommand{\\bfS}{\\mathbf{S}}\n\\newcommand{\\bfT}{\\mathbf{T}}\n\\newcommand{\\bfU}{\\mathbf{U}}\n\\newcommand{\\bfV}{\\mathbf{V}}\n\\newcommand{\\bfW}{\\mathbf{W}}\n\\newcommand{\\bfX}{\\mathbf{X}}\n\\newcommand{\\bfY}{\\mathbf{Y}}\n\\newcommand{\\bfZ}{\\mathbf{Z}}\n\n```\n\n</details>\n<br>\n:::\n\n\n\nHope you have fun using this to quickly generate your $\\LaTeX$ `newcommand`\nmacros ✌️.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}